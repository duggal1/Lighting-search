/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/flat";
exports.ids = ["vendor-chunks/flat"];
exports.modules = {

/***/ "(rsc)/./node_modules/flat/index.js":
/*!************************************!*\
  !*** ./node_modules/flat/index.js ***!
  \************************************/
/***/ ((module) => {

eval("module.exports = flatten\nflatten.flatten = flatten\nflatten.unflatten = unflatten\n\nfunction isBuffer (obj) {\n  return obj &&\n    obj.constructor &&\n    (typeof obj.constructor.isBuffer === 'function') &&\n    obj.constructor.isBuffer(obj)\n}\n\nfunction keyIdentity (key) {\n  return key\n}\n\nfunction flatten (target, opts) {\n  opts = opts || {}\n\n  const delimiter = opts.delimiter || '.'\n  const maxDepth = opts.maxDepth\n  const transformKey = opts.transformKey || keyIdentity\n  const output = {}\n\n  function step (object, prev, currentDepth) {\n    currentDepth = currentDepth || 1\n    Object.keys(object).forEach(function (key) {\n      const value = object[key]\n      const isarray = opts.safe && Array.isArray(value)\n      const type = Object.prototype.toString.call(value)\n      const isbuffer = isBuffer(value)\n      const isobject = (\n        type === '[object Object]' ||\n        type === '[object Array]'\n      )\n\n      const newKey = prev\n        ? prev + delimiter + transformKey(key)\n        : transformKey(key)\n\n      if (!isarray && !isbuffer && isobject && Object.keys(value).length &&\n        (!opts.maxDepth || currentDepth < maxDepth)) {\n        return step(value, newKey, currentDepth + 1)\n      }\n\n      output[newKey] = value\n    })\n  }\n\n  step(target)\n\n  return output\n}\n\nfunction unflatten (target, opts) {\n  opts = opts || {}\n\n  const delimiter = opts.delimiter || '.'\n  const overwrite = opts.overwrite || false\n  const transformKey = opts.transformKey || keyIdentity\n  const result = {}\n\n  const isbuffer = isBuffer(target)\n  if (isbuffer || Object.prototype.toString.call(target) !== '[object Object]') {\n    return target\n  }\n\n  // safely ensure that the key is\n  // an integer.\n  function getkey (key) {\n    const parsedKey = Number(key)\n\n    return (\n      isNaN(parsedKey) ||\n      key.indexOf('.') !== -1 ||\n      opts.object\n    ) ? key\n      : parsedKey\n  }\n\n  function addKeys (keyPrefix, recipient, target) {\n    return Object.keys(target).reduce(function (result, key) {\n      result[keyPrefix + delimiter + key] = target[key]\n\n      return result\n    }, recipient)\n  }\n\n  function isEmpty (val) {\n    const type = Object.prototype.toString.call(val)\n    const isArray = type === '[object Array]'\n    const isObject = type === '[object Object]'\n\n    if (!val) {\n      return true\n    } else if (isArray) {\n      return !val.length\n    } else if (isObject) {\n      return !Object.keys(val).length\n    }\n  }\n\n  target = Object.keys(target).reduce(function (result, key) {\n    const type = Object.prototype.toString.call(target[key])\n    const isObject = (type === '[object Object]' || type === '[object Array]')\n    if (!isObject || isEmpty(target[key])) {\n      result[key] = target[key]\n      return result\n    } else {\n      return addKeys(\n        key,\n        result,\n        flatten(target[key], opts)\n      )\n    }\n  }, {})\n\n  Object.keys(target).forEach(function (key) {\n    const split = key.split(delimiter).map(transformKey)\n    let key1 = getkey(split.shift())\n    let key2 = getkey(split[0])\n    let recipient = result\n\n    while (key2 !== undefined) {\n      if (key1 === '__proto__') {\n        return\n      }\n\n      const type = Object.prototype.toString.call(recipient[key1])\n      const isobject = (\n        type === '[object Object]' ||\n        type === '[object Array]'\n      )\n\n      // do not write over falsey, non-undefined values if overwrite is false\n      if (!overwrite && !isobject && typeof recipient[key1] !== 'undefined') {\n        return\n      }\n\n      if ((overwrite && !isobject) || (!overwrite && recipient[key1] == null)) {\n        recipient[key1] = (\n          typeof key2 === 'number' &&\n          !opts.object ? [] : {}\n        )\n      }\n\n      recipient = recipient[key1]\n      if (split.length > 0) {\n        key1 = getkey(split.shift())\n        key2 = getkey(split[0])\n      }\n    }\n\n    // unflatten again for 'messy objects'\n    recipient[key1] = unflatten(target[key], opts)\n  })\n\n  return result\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZmxhdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSTs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGh1bmRlci1zZWFyY2gvLi9ub2RlX21vZHVsZXMvZmxhdC9pbmRleC5qcz84YmVmIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZmxhdHRlblxuZmxhdHRlbi5mbGF0dGVuID0gZmxhdHRlblxuZmxhdHRlbi51bmZsYXR0ZW4gPSB1bmZsYXR0ZW5cblxuZnVuY3Rpb24gaXNCdWZmZXIgKG9iaikge1xuICByZXR1cm4gb2JqICYmXG4gICAgb2JqLmNvbnN0cnVjdG9yICYmXG4gICAgKHR5cGVvZiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicpICYmXG4gICAgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyKG9iailcbn1cblxuZnVuY3Rpb24ga2V5SWRlbnRpdHkgKGtleSkge1xuICByZXR1cm4ga2V5XG59XG5cbmZ1bmN0aW9uIGZsYXR0ZW4gKHRhcmdldCwgb3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fVxuXG4gIGNvbnN0IGRlbGltaXRlciA9IG9wdHMuZGVsaW1pdGVyIHx8ICcuJ1xuICBjb25zdCBtYXhEZXB0aCA9IG9wdHMubWF4RGVwdGhcbiAgY29uc3QgdHJhbnNmb3JtS2V5ID0gb3B0cy50cmFuc2Zvcm1LZXkgfHwga2V5SWRlbnRpdHlcbiAgY29uc3Qgb3V0cHV0ID0ge31cblxuICBmdW5jdGlvbiBzdGVwIChvYmplY3QsIHByZXYsIGN1cnJlbnREZXB0aCkge1xuICAgIGN1cnJlbnREZXB0aCA9IGN1cnJlbnREZXB0aCB8fCAxXG4gICAgT2JqZWN0LmtleXMob2JqZWN0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gb2JqZWN0W2tleV1cbiAgICAgIGNvbnN0IGlzYXJyYXkgPSBvcHRzLnNhZmUgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSlcbiAgICAgIGNvbnN0IHR5cGUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpXG4gICAgICBjb25zdCBpc2J1ZmZlciA9IGlzQnVmZmVyKHZhbHVlKVxuICAgICAgY29uc3QgaXNvYmplY3QgPSAoXG4gICAgICAgIHR5cGUgPT09ICdbb2JqZWN0IE9iamVjdF0nIHx8XG4gICAgICAgIHR5cGUgPT09ICdbb2JqZWN0IEFycmF5XSdcbiAgICAgIClcblxuICAgICAgY29uc3QgbmV3S2V5ID0gcHJldlxuICAgICAgICA/IHByZXYgKyBkZWxpbWl0ZXIgKyB0cmFuc2Zvcm1LZXkoa2V5KVxuICAgICAgICA6IHRyYW5zZm9ybUtleShrZXkpXG5cbiAgICAgIGlmICghaXNhcnJheSAmJiAhaXNidWZmZXIgJiYgaXNvYmplY3QgJiYgT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aCAmJlxuICAgICAgICAoIW9wdHMubWF4RGVwdGggfHwgY3VycmVudERlcHRoIDwgbWF4RGVwdGgpKSB7XG4gICAgICAgIHJldHVybiBzdGVwKHZhbHVlLCBuZXdLZXksIGN1cnJlbnREZXB0aCArIDEpXG4gICAgICB9XG5cbiAgICAgIG91dHB1dFtuZXdLZXldID0gdmFsdWVcbiAgICB9KVxuICB9XG5cbiAgc3RlcCh0YXJnZXQpXG5cbiAgcmV0dXJuIG91dHB1dFxufVxuXG5mdW5jdGlvbiB1bmZsYXR0ZW4gKHRhcmdldCwgb3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fVxuXG4gIGNvbnN0IGRlbGltaXRlciA9IG9wdHMuZGVsaW1pdGVyIHx8ICcuJ1xuICBjb25zdCBvdmVyd3JpdGUgPSBvcHRzLm92ZXJ3cml0ZSB8fCBmYWxzZVxuICBjb25zdCB0cmFuc2Zvcm1LZXkgPSBvcHRzLnRyYW5zZm9ybUtleSB8fCBrZXlJZGVudGl0eVxuICBjb25zdCByZXN1bHQgPSB7fVxuXG4gIGNvbnN0IGlzYnVmZmVyID0gaXNCdWZmZXIodGFyZ2V0KVxuICBpZiAoaXNidWZmZXIgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRhcmdldCkgIT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgcmV0dXJuIHRhcmdldFxuICB9XG5cbiAgLy8gc2FmZWx5IGVuc3VyZSB0aGF0IHRoZSBrZXkgaXNcbiAgLy8gYW4gaW50ZWdlci5cbiAgZnVuY3Rpb24gZ2V0a2V5IChrZXkpIHtcbiAgICBjb25zdCBwYXJzZWRLZXkgPSBOdW1iZXIoa2V5KVxuXG4gICAgcmV0dXJuIChcbiAgICAgIGlzTmFOKHBhcnNlZEtleSkgfHxcbiAgICAgIGtleS5pbmRleE9mKCcuJykgIT09IC0xIHx8XG4gICAgICBvcHRzLm9iamVjdFxuICAgICkgPyBrZXlcbiAgICAgIDogcGFyc2VkS2V5XG4gIH1cblxuICBmdW5jdGlvbiBhZGRLZXlzIChrZXlQcmVmaXgsIHJlY2lwaWVudCwgdGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRhcmdldCkucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIGtleSkge1xuICAgICAgcmVzdWx0W2tleVByZWZpeCArIGRlbGltaXRlciArIGtleV0gPSB0YXJnZXRba2V5XVxuXG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfSwgcmVjaXBpZW50KVxuICB9XG5cbiAgZnVuY3Rpb24gaXNFbXB0eSAodmFsKSB7XG4gICAgY29uc3QgdHlwZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWwpXG4gICAgY29uc3QgaXNBcnJheSA9IHR5cGUgPT09ICdbb2JqZWN0IEFycmF5XSdcbiAgICBjb25zdCBpc09iamVjdCA9IHR5cGUgPT09ICdbb2JqZWN0IE9iamVjdF0nXG5cbiAgICBpZiAoIXZhbCkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkpIHtcbiAgICAgIHJldHVybiAhdmFsLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAoaXNPYmplY3QpIHtcbiAgICAgIHJldHVybiAhT2JqZWN0LmtleXModmFsKS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB0YXJnZXQgPSBPYmplY3Qua2V5cyh0YXJnZXQpLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBrZXkpIHtcbiAgICBjb25zdCB0eXBlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRhcmdldFtrZXldKVxuICAgIGNvbnN0IGlzT2JqZWN0ID0gKHR5cGUgPT09ICdbb2JqZWN0IE9iamVjdF0nIHx8IHR5cGUgPT09ICdbb2JqZWN0IEFycmF5XScpXG4gICAgaWYgKCFpc09iamVjdCB8fCBpc0VtcHR5KHRhcmdldFtrZXldKSkge1xuICAgICAgcmVzdWx0W2tleV0gPSB0YXJnZXRba2V5XVxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYWRkS2V5cyhcbiAgICAgICAga2V5LFxuICAgICAgICByZXN1bHQsXG4gICAgICAgIGZsYXR0ZW4odGFyZ2V0W2tleV0sIG9wdHMpXG4gICAgICApXG4gICAgfVxuICB9LCB7fSlcblxuICBPYmplY3Qua2V5cyh0YXJnZXQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGNvbnN0IHNwbGl0ID0ga2V5LnNwbGl0KGRlbGltaXRlcikubWFwKHRyYW5zZm9ybUtleSlcbiAgICBsZXQga2V5MSA9IGdldGtleShzcGxpdC5zaGlmdCgpKVxuICAgIGxldCBrZXkyID0gZ2V0a2V5KHNwbGl0WzBdKVxuICAgIGxldCByZWNpcGllbnQgPSByZXN1bHRcblxuICAgIHdoaWxlIChrZXkyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChrZXkxID09PSAnX19wcm90b19fJykge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgY29uc3QgdHlwZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChyZWNpcGllbnRba2V5MV0pXG4gICAgICBjb25zdCBpc29iamVjdCA9IChcbiAgICAgICAgdHlwZSA9PT0gJ1tvYmplY3QgT2JqZWN0XScgfHxcbiAgICAgICAgdHlwZSA9PT0gJ1tvYmplY3QgQXJyYXldJ1xuICAgICAgKVxuXG4gICAgICAvLyBkbyBub3Qgd3JpdGUgb3ZlciBmYWxzZXksIG5vbi11bmRlZmluZWQgdmFsdWVzIGlmIG92ZXJ3cml0ZSBpcyBmYWxzZVxuICAgICAgaWYgKCFvdmVyd3JpdGUgJiYgIWlzb2JqZWN0ICYmIHR5cGVvZiByZWNpcGllbnRba2V5MV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBpZiAoKG92ZXJ3cml0ZSAmJiAhaXNvYmplY3QpIHx8ICghb3ZlcndyaXRlICYmIHJlY2lwaWVudFtrZXkxXSA9PSBudWxsKSkge1xuICAgICAgICByZWNpcGllbnRba2V5MV0gPSAoXG4gICAgICAgICAgdHlwZW9mIGtleTIgPT09ICdudW1iZXInICYmXG4gICAgICAgICAgIW9wdHMub2JqZWN0ID8gW10gOiB7fVxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIHJlY2lwaWVudCA9IHJlY2lwaWVudFtrZXkxXVxuICAgICAgaWYgKHNwbGl0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAga2V5MSA9IGdldGtleShzcGxpdC5zaGlmdCgpKVxuICAgICAgICBrZXkyID0gZ2V0a2V5KHNwbGl0WzBdKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHVuZmxhdHRlbiBhZ2FpbiBmb3IgJ21lc3N5IG9iamVjdHMnXG4gICAgcmVjaXBpZW50W2tleTFdID0gdW5mbGF0dGVuKHRhcmdldFtrZXldLCBvcHRzKVxuICB9KVxuXG4gIHJldHVybiByZXN1bHRcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/flat/index.js\n");

/***/ })

};
;